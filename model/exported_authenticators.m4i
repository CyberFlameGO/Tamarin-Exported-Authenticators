include(crypto.m4i)dnl
include(msgs.m4i)dnl
dnl include(adversary.m4i)dnl

rule Register_pk:
    [ Fr(~ltk) ]
  -->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]


rule Get_pk:
    [ !Pk(A, pubkey) ]
  -->
     [ Out(pubkey) ]

rule Create_TLS_channel:
    [ Fr(ms)
    , Fr(TLS_transcript) 
    , Fr(cid)
    , Create_TLS_Channel(owner_host, owner_cid, target_host)
    ]
  --[
      SessionKey(ms, TLS_transcript)
    ]->
    [ !TLS_Channel(ms, TLS_transcript, owner_host, owner_cid, target_host, cid)
    , !Exporters(ms, 'server',  cid, Handshake_Context(client), Handshake_Context(server), Finished_MAC(client), Finished_MAC(server))
    , !Exporters(ms, 'client', owner_cid, Handshake_Context(client), Handshake_Context(server), Finished_MAC(client), Finished_MAC(server))
    ]

rule Send_TLS_Channel_owner:
    [ TLS_Send(cid, from_host, to_host, msg)
    , !TLS_Channel(ms, TLS_transcript, owner_host, owner_cid, target_host, target_cid)
    ]
  --[ Check_pair_or_swapped(from_host, to_host, owner_host, target_host)
    , Eq(cid, owner_cid)
    ]->
    [ TLS_Recv(target_cid, from_host, to_host, msg) ]

rule Send_TLS_Channel_target:
    [ TLS_Send(cid, from_host, to_host, msg)
    , !TLS_Channel(ms, TLS_transcript, owner_host, owner_cid, target_host, target_cid)
    ]
  --[ Check_pair_or_swapped(from_host, to_host, owner_host, target_host)
    , Eq(cid, target_cid)
    ]->
    [ TLS_Recv(owner_cid, from_host, to_host, msg) ]

/* Protocol */
rule C_0:
  let
    C=$C
    S=$S
  in
    [ Fr(~tid)
    ]
  --[ Start(~tid, C, 'client') 
    , C0(~tid)
    ]->
    [ State(~tid, 'C0', C, S, 'client')
    , Create_TLS_Channel(C, ~tid, S)
    ]

rule C_Send:
  let
    C=$C
    S=$S
    certificate_request_context=~certificate_request_context
    certificate=pk(~ltkC)
    signature=compute_signature(~ltkC, h(hccc, certificate))
    verify_data = hmac(fmc, <hccc, Certificate, CertificateVerify>)
  in
    [ State(~tid, 'C0', C, S, 'client')
    , Fr(~certificate_request_context)
    , !Exporters(~ms, 'client', ~tid, hccc, hccs, fmc, fms)
    , !Ltk($C, ~ltkC)
    ]
  --[ C_Send(~tid)
    , Owns($C, ~ltkC)
    , Instance(~tid, C, 'client')
    ]->
    [ State(~tid, 'C0', C, S, 'client')
    , TLS_Send(~tid, C, S, <Certificate, CertificateVerify, Finished>) 
    ]
    
rule C_Recv:
  let 
    C=$C
    S=$S
    certificate=pk(~ltkS)
    sig_msg=signature_input(h(hccs, certificate))
    exp_verify_data = hmac(fms, <hccs, Certificate, CertificateVerify>)
  in
    [ State(~tid, 'C0', C, S, 'client')
    , TLS_Recv(~tid, C, S, <Certificate, CertificateVerify, Finished>)
    , !Exporters(~ms, 'client', ~tid, hccc, hccs, fmc, fms)
    , !Pk($S, pk(~ltkS))
    ]
  --[ C_Recv(~tid)
    , Eq(verify(signature, sig_msg, pk(~ltkS)), true)
    , Eq(verify_data, exp_verify_data)
    , Recv(C, S, pk(~ltkS))
    , Instance(~tid, C, 'client')
    ]->
    [ State(~tid, 'C0', C, S, 'client')
    , !AcceptOwnership(~tid, C, S, pk(~ltkS))
    ]

rule S_0:
  let
    C=$C
    S=$S
  in
    [ !Exporters(~ms, 'server', ~tid, hccc, hccs, fmc, fms)
    ]
  --[ Start(~tid, S, 'server')
    , S0(~tid)
    ]->
    [ State(~tid, 'S0', S, C, 'server')
    ]

rule S_Recv:
  let 
    C=$C
    S=$S
    certificate=pk(~ltkC)
    sig_msg=signature_input(h(hccc, certificate))
    exp_verify_data = hmac(fmc, <hccc, Certificate, CertificateVerify>)
  in
    [ State(~tid, 'S0', S, C, 'server')
    , TLS_Recv(~tid, C, S, <Certificate, CertificateVerify, Finished>)
    , !Exporters(~ms, 'server', ~tid, hccc, hccs, fmc, fms)
    , !Pk($C, pk(~ltkC))
    ]
  --[ S_Recv(~tid)
    , Eq(verify(signature, sig_msg, pk(~ltkC)), true)
    , Eq(verify_data,exp_verify_data)
    , Recv(S, C, pk(~ltkC))
    , Instance(~tid, S, 'server')
    ]->
    [ State(~tid, 'S0', S, C, 'server')
    , !AcceptOwnership(~tid, C, S, pk(~ltkC))
    ]

rule S_Send:
  let
    C=$C
    S=$S
    certificate_request_context=~certificate_request_context
    certificate=pk(~ltkS)
    signature=compute_signature(~ltkS, h(hccs, certificate))
    verify_data = hmac(fms, <hccs, Certificate, CertificateVerify>)
  in
    [ State(~tid, 'S0', S, C, 'server')
    , Fr(~certificate_request_context)
    , !Exporters(~ms, 'server', ~tid, hccc, hccs, fmc, fms)
    , !Ltk($S, ~ltkS)
    ]
  --[ S_Send(~tid)
    , Owns($S, ~ltkS)
    , Instance(~tid, S, 'server')
    ]->
    [ State(~tid, 'S0', S, C, 'server')
    , TLS_Send(~tid, C, S, <Certificate, CertificateVerify, Finished>)
    ]
