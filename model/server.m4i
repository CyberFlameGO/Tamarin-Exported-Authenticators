rule S_0:
  let
    C=$C
    S=$S
  in
    [ Create_TLS_Channel(C, cid, S)
    , Fr(~sid)
    , !Ltk($S, ltkS)
    ]
  --[ PreStart(~sid, S, C, 'server')
    ]->
    [ Create_TLS_Channel2(C, cid, S, ~sid, pk(ltkS))
    , State(~sid, 'S0', S, C, 'server', 'none')
    ]

rule S_1_uni:
  let
    C=$C
    S=$S
  in
    [ Create_TLS_Channel3(C, cid, 'none', S,  ~sid, pk(ltkS))
    , State(~sid, 'S0', S, C, 'server', 'none')
    ]
  --[ Start(~sid, S, C, 'server')
    , S1(~sid)
    ]->
    [ State(~sid, 'S1', S, C, 'server', 'none')
    , Create_TLS_Channel4(C, cid, 'none', S, ~sid, pk(ltkS), 'uni')
    ]

rule S_1_bi:
  let
    C=$C
    S=$S
  in
    [ Create_TLS_Channel3(C, cid, pk(ltkC),  S, ~sid, pk(ltkS))
    , State(~sid, 'S0', S, C, 'server', 'none')
    , !Pk(C, pk(ltkC))
    ]
  --[ Start(~sid, S, C, 'server')
    , S1(~sid)
    ]->
    [ State(~sid, 'S1', S, C, 'server', 'auth')
    , Create_TLS_Channel4(C, cid, pk(ltkC), S, ~sid, pk(ltkS), 'bi')
    ]

rule S_Request:
  let
    C=$C
    S=$S
    certificate_request_context=~certificate_request_context
  in
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , !TLS_Channel(ms, TLS_transcript, auth_status, $C, cid, $S, ~sid)
    , Fr(~certificate_request_context)
    , Fr(~request_id)
    ]
  --[ S_Req(~sid, ~certificate_request_context)
    , Instance(~sid, S, C, 'server')
    , Requested(~sid, S, 'server', certificate_request_context)
    , TLS_Sent(ms)
    ]->
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , TLS_Send(~sid, S, C, CertificateRequest)
    , PendingReqI(~request_id, ~sid, 'server', CertificateRequest)
    ]

rule S_RecvReq:
  let
    C=$C
    S=$S
  in
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , TLS_Recv(~sid, C, S, CertificateRequest)
    , !Exporters(ms, 'server', ~sid, hccc, hccs, fmc, fms)
    , Fr(~request_id)
    ]
  --[ S_RecvReq(~sid)
    , RecvReq(S, ms, 'server', certificate_request_context)
    , Instance(~sid, S, C, 'server')
    , TLS_Recvd(ms)
    ]->
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , PendingReqR(~request_id, ~sid, 'server', CertificateRequest)
    ]

rule S_Send:
  let
    C=$C
    S=$S
    certificate_request_context=~certificate_request_context
    certificate=pk(ltkA)
    signature=compute_signature(ltkA, h(hccs, CertificateRequest, certificate))
    verify_data = hmac(fms, <hccs, CertificateRequest, Certificate, CertificateVerify>)
  in
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , PendingReqR(~request_id, ~sid, 'server', CertificateRequest)
    , !Exporters(ms, 'server', ~sid, hccc, hccs, fmc, fms)
    , !Ltk($A, ltkA)
    , DelegateLtk($S, ltkA)  
    ]
  --[ S_Send(~sid)
    , Owns(S, ms, 'server', <$A, ltkA>)
    , Instance(~sid, S, C, 'server')
    , Fulfil(~sid, S, 'server', certificate_request_context, <$A, ltkA>)
    , TLS_Sent(ms)
    ]->
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , TLS_Send(~sid, S, C, <Certificate, CertificateVerify, Finished>)
    ]

rule S_Recv:
  let 
    C=$C
    S=$S
    certificate=pk(ltkA)
    sig_msg=signature_input(h(hccc, CertificateRequest, certificate))
    exp_verify_data = hmac(fmc, <hccc, CertificateRequest, Certificate, CertificateVerify>)
  in
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , TLS_Recv(~sid, C, S, <Certificate, CertificateVerify, Finished>)
    , PendingReqI(~request_id, ~sid, 'server', CertificateRequest)
    , !Exporters(ms, 'server', ~sid, hccc, hccs, fmc, fms)
    , !Pk($A, pk(ltkA))
    ]
  --[ S_Recv(~sid)
    , Eq(verify(signature, sig_msg, pk(ltkA)), true)
    , Eq(verify_data,exp_verify_data)
    , Recv(S, ms, 'server', <$A, pk(ltkA)>)
    , Fulfilled(~sid, S, 'server', certificate_request_context, <$A, pk(ltkA)>)
    , Instance(~sid, S, C, 'server')
    , TLS_Recvd(ms)
    ]->
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    ]

rule S_Send_Spontaneous:
  let
    C=$C
    S=$S
    certificate=pk(ltkA)
    signature=compute_signature(ltkA, h(hccs, certificate))
    verify_data = hmac(fms, <hccs, Certificate_Spontaneous, CertificateVerify>)
  in
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , !Exporters(ms, 'server', ~sid, hccc, hccs, fmc, fms)
    , !Ltk($A, ltkA)
    , DelegateLtk($S, ltkA)  
    ]
  --[ S_Send(~sid)
    , Owns(S, ms, 'server', <$A, ltkA>)
    , Instance(~sid, S, C, 'server')
    , TLS_Sent(ms)
    ]->
    [ State(~sid, 'S1', S, C, 'server', auth_status)
    , TLS_Send(~sid, S, C, <Certificate_Spontaneous, CertificateVerify, Finished>)
    ]
