theory ExportedAuthenticators_Reachability begin

// Function signature and definition of the equational theory E

functions: Expand/3, Exporter/3, Extract/2, adec/2, aenc/2, fst/1,
           h/1, hmac/1, mac/1, mask/2, pair/2, pk/1, sign/2, snd/1, true/0,
           unmask/2, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    unmask(mask(x, y), x) = y,
    unmask(mask(x, y), y) = x,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

/* looping facts with injective instances: F_State/6 */

section{* TLS Exported Authenticators*}

restriction Eq_check_succeed:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Neq_check_succeed:
  "∀ x y #i. (Neq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

restriction pair_or_swapped:
  "∀ x y a b #i.
    (Check_pair_or_swapped( x, y, a, b ) @ #i) ⇒
    (((x = a) ∧ (y = b)) ∨ ((x = b) ∧ (y = a)))"
  // safety formula

rule (modulo E) Register_pk:
   [ Fr( ~ltk ) ]
  -->
   [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ), DelegateLtk( $TP, ~ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   [ !Pk( A, pubkey ) ] --> [ Out( pubkey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_TLS_channel_bi:
   [
   Fr( ms ), Fr( TLS_transcript ),
   Create_TLS_Channel4( $C, nc, pk(ltkC), $S, ns, pk(ltkS) )
   ]
  --[ SessionKey( ms, TLS_transcript ) ]->
   [
   !TLS_Channel( ms, TLS_transcript, 'bi', $C, nc, $S, ns ),
   !Exporters( ms, 'server', ns,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   ),
   !Exporters( ms, 'client', nc,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_TLS_channel_uni:
   [
   Fr( ms ), Fr( TLS_transcript ), Fr( cid ),
   Create_TLS_Channel4( $C, nc, 'none', $S, ns, pk(ltkS) )
   ]
  --[ SessionKey( ms, TLS_transcript ) ]->
   [
   !TLS_Channel( ms, TLS_transcript, 'uni', $C, nc, $S, ns ),
   !Exporters( ms, 'server', ns,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   ),
   !Exporters( ms, 'client', nc,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_TLS_Channel_owner:
   [
   TLS_Send( nc, $C, $S, msg ),
   !TLS_Channel( ms, TLS_transcript, state, $C, nc, $S, ns )
   ]
  -->
   [ TLS_Recv( ns, $C, $S, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_TLS_Channel_target:
   [
   TLS_Send( ns, $S, $C, msg ),
   !TLS_Channel( ms, TLS_transcript, state, $C, nc, $S, ns )
   ]
  -->
   [ TLS_Recv( nc, $S, $C, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_0:
   [ Fr( ~cid ) ]
  --[ PreStart( ~cid, $C, $S, 'client' ), C0( ~cid ), Neq( $C, $S )
  ]->
   [
   F_State( ~cid, 'C0', $C, $S, 'client', 'none' ),
   Create_TLS_Channel( $C, ~cid, $S )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_1_uni:
   [
   Create_TLS_Channel2( $C, ~cid, $S, sid, pk(ltkS) ),
   F_State( ~cid, 'C0', $C, $S, 'client', 'none' ),
   !Pk( $S, pk(ltkS) )
   ]
  --[ C1( ~cid ), Start( ~cid, $C, $S, 'client' ) ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', 'auth' ),
   Create_TLS_Channel3( $C, ~cid, 'none', $S, sid, pk(ltkS) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_1_bi:
   [
   Create_TLS_Channel2( $C, ~cid, $S, sid, pk(ltkS) ),
   F_State( ~cid, 'C0', $C, $S, 'client', 'none' ),
   !Pk( $S, pk(ltkS) ), !Ltk( $C, ltkC )
   ]
  --[ C1( ~cid ), Start( ~cid, $C, $S, 'client' ) ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', 'auth' ),
   Create_TLS_Channel3( $C, ~cid, pk(ltkC), $S, sid, pk(ltkS) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_Request:
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   Fr( ~certificate_request_context )
   ]
  --[
  C_Req( ~cid, ~certificate_request_context ),
  Instance( ~cid, $C, $S, 'client' ),
  Requested( ~cid, $C, 'client',
             <'13', ~certificate_request_context, $certificate_extensions>
  )
  ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   TLS_Send( ~cid, $C, $S,
             <'13', ~certificate_request_context, $certificate_extensions>
   ),
   PendingReq( ~cid, 'client',
               <'13', ~certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) C_RecvReq:
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   TLS_Recv( ~cid, $S, $C,
             <'13', certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms )
   ]
  --[
  C_RecvReq( ~cid ),
  RecvReq( $C, ms, 'client',
           <'13', certificate_request_context, $certificate_extensions>
  ),
  Instance( ~cid, $C, $S, 'client' )
  ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   PendingReq( ~cid, 'client',
               <'13', certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) C_Send:
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   PendingReq( ~cid, 'client',
               <'13', ~certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ltkA ), DelegateLtk( $C, ltkA )
   ]
  --[
  C_Send( ~cid ), Owns( $C, ms, 'client', <$A, ltkA> ),
  Instance( ~cid, $C, $S, 'client' ),
  Fulfil( ~cid, $C, 'client',
          <'13', ~certificate_request_context, $certificate_extensions>,
          <$A, pk(ltkA)>
  )
  ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   TLS_Send( ~cid, $C, $S,
             <<'11', ~certificate_request_context, pk(ltkA)>, 
              <'15', 
               sign(<'ExportedAuthenticator', 
                     h(<hccc, 
                        <'13', ~certificate_request_context, $certificate_extensions>, 
                        pk(ltkA)>)
                    >,
                    ltkA)
              >, 
              '20', 
              hmac(<fmc, hccc, 
                    <'13', ~certificate_request_context, $certificate_extensions>, 
                    <'11', ~certificate_request_context, pk(ltkA)>, '15', 
                    sign(<'ExportedAuthenticator', 
                          h(<hccc, 
                             <'13', ~certificate_request_context, $certificate_extensions>, 
                             pk(ltkA)>)
                         >,
                         ltkA)
                   >)
             >
   )
   ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

rule (modulo E) C_Recv:
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   TLS_Recv( ~cid, $S, $C,
             <<'11', certificate_request_context, pk(ltkA)>, <'15', signature>, 
              '20', verify_data>
   ),
   PendingReq( ~cid, 'client',
               <'13', certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms ),
   !Pk( $A, pk(ltkA) )
   ]
  --[
  C_Recv( ~cid ),
  Eq( verify(signature,
             <'ExportedAuthenticator', 
              h(<hccs, 
                 <'13', certificate_request_context, $certificate_extensions>, 
                 pk(ltkA)>)
             >,
             pk(ltkA)),
      true
  ),
  Eq( verify_data,
      hmac(<fms, hccs, 
            <'13', certificate_request_context, $certificate_extensions>, 
            <'11', certificate_request_context, pk(ltkA)>, '15', signature>)
  ),
  Recv( $C, ms, 'client', <$A, pk(ltkA)> ),
  Fulfilled( ~cid, $C, 'client',
             <'13', certificate_request_context, $certificate_extensions>,
             <$A, pk(ltkA)>
  ),
  Instance( ~cid, $C, $S, 'client' )
  ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   !AcceptOwnership( ~cid, $C, $S, pk(ltkA) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) C_Recv:
     [
     F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
     TLS_Recv( ~cid, $S, $C,
               <<'11', certificate_request_context, pk(ltkA)>, <'15', signature>, 
                '20', verify_data>
     ),
     PendingReq( ~cid, 'client',
                 <'13', certificate_request_context, $certificate_extensions>
     ),
     !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms ),
     !Pk( $A, pk(ltkA) )
     ]
    --[
    C_Recv( ~cid ), Eq( z, true ),
    Eq( verify_data,
        hmac(<fms, hccs, 
              <'13', certificate_request_context, $certificate_extensions>, 
              <'11', certificate_request_context, pk(ltkA)>, '15', signature>)
    ),
    Recv( $C, ms, 'client', <$A, pk(ltkA)> ),
    Fulfilled( ~cid, $C, 'client',
               <'13', certificate_request_context, $certificate_extensions>,
               <$A, pk(ltkA)>
    ),
    Instance( ~cid, $C, $S, 'client' )
    ]->
     [
     F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
     !AcceptOwnership( ~cid, $C, $S, pk(ltkA) )
     ]
    variants (modulo AC)
    1. $certificate_extensions
             = $certificate_extensions.32
       certificate_request_context
             = certificate_request_context.35
       hccs  = hccs.39
       ltkA  = ltkA.40
       signature
             = sign(<'ExportedAuthenticator', 
                     h(<hccs.39, 
                        <'13', certificate_request_context.35, $certificate_extensions.32
                        >, 
                        pk(ltkA.40)>)
                    >,
                    ltkA.40)
       z     = true
    
    2. $certificate_extensions
             = $certificate_extensions.34
       certificate_request_context
             = certificate_request_context.37
       hccs  = hccs.41
       ltkA  = ltkA.42
       signature
             = signature.44
       z     = verify(signature.44,
                      <'ExportedAuthenticator', 
                       h(<hccs.41, 
                          <'13', certificate_request_context.37, $certificate_extensions.34
                          >, 
                          pk(ltkA.42)>)
                      >,
                      pk(ltkA.42))
    // loop breaker: [0]
  */

rule (modulo E) C_Recv_Spontaneous:
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   TLS_Recv( ~cid, $S, $C,
             <<'11', pk(ltkA)>, <'15', signature>, '20', verify_data>
   ),
   !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms ),
   !Pk( $A, pk(ltkA) )
   ]
  --[
  C_Recv( ~cid ),
  Eq( verify(signature,
             <'ExportedAuthenticator', h(<hccs, pk(ltkA)>)>, pk(ltkA)),
      true
  ),
  Eq( verify_data,
      hmac(<fms, hccs, <'11', pk(ltkA)>, '15', signature>)
  ),
  Recv( $C, ms, 'client', <$A, pk(ltkA)> ),
  Instance( ~cid, $C, $S, 'client' )
  ]->
   [
   F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
   !AcceptOwnership( ~cid, $C, $S, pk(ltkA) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) C_Recv_Spontaneous:
     [
     F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
     TLS_Recv( ~cid, $S, $C,
               <<'11', pk(ltkA)>, <'15', signature>, '20', verify_data>
     ),
     !Exporters( ms, 'client', ~cid, hccc, hccs, fmc, fms ),
     !Pk( $A, pk(ltkA) )
     ]
    --[
    C_Recv( ~cid ), Eq( z, true ),
    Eq( verify_data,
        hmac(<fms, hccs, <'11', pk(ltkA)>, '15', signature>)
    ),
    Recv( $C, ms, 'client', <$A, pk(ltkA)> ),
    Instance( ~cid, $C, $S, 'client' )
    ]->
     [
     F_State( ~cid, 'C1', $C, $S, 'client', auth_status ),
     !AcceptOwnership( ~cid, $C, $S, pk(ltkA) )
     ]
    variants (modulo AC)
    1. hccs  = hccs.22
       ltkA  = ltkA.23
       signature
             = sign(<'ExportedAuthenticator', h(<hccs.22, pk(ltkA.23)>)>,
                    ltkA.23)
       z     = true
    
    2. hccs  = hccs.24
       ltkA  = ltkA.25
       signature
             = signature.27
       z     = verify(signature.27,
                      <'ExportedAuthenticator', h(<hccs.24, pk(ltkA.25)>)>, pk(ltkA.25))
    // loop breaker: [0]
  */

rule (modulo E) S_0:
   [ Create_TLS_Channel( $C, cid, $S ), Fr( ~sid ), !Ltk( $S, ltkS ) ]
  --[ PreStart( ~sid, $S, $C, 'server' ) ]->
   [
   Create_TLS_Channel2( $C, cid, $S, ~sid, pk(ltkS) ),
   F_State( ~sid, 'S0', $S, $C, 'server', 'none' )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) S_1_uni:
   [
   Create_TLS_Channel3( $C, cid, 'none', $S, ~sid, pk(ltkS) ),
   F_State( ~sid, 'S0', $S, $C, 'server', 'none' )
   ]
  --[ Start( ~sid, $S, $C, 'server' ), S1( ~sid ) ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', 'none' ),
   Create_TLS_Channel4( $C, cid, 'none', $S, ~sid, pk(ltkS) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) S_1_bi:
   [
   Create_TLS_Channel3( $C, cid, pk(ltkC), $S, ~sid, pk(ltkS) ),
   F_State( ~sid, 'S0', $S, $C, 'server', 'none' ),
   !Pk( $C, pk(ltkC) )
   ]
  --[ Start( ~sid, $S, $C, 'server' ), S1( ~sid ) ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', 'auth' ),
   Create_TLS_Channel4( $C, cid, pk(ltkC), $S, ~sid, pk(ltkS) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) S_Request:
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   Fr( ~certificate_request_context )
   ]
  --[
  S_Req( ~sid, ~certificate_request_context ),
  Instance( ~sid, $S, $C, 'server' ),
  Requested( ~sid, $S, 'server',
             <'13', ~certificate_request_context, $certificate_extensions>
  )
  ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   TLS_Send( ~sid, $S, $C,
             <'13', ~certificate_request_context, $certificate_extensions>
   ),
   PendingReq( ~sid, 'server',
               <'13', ~certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S_RecvReq:
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   TLS_Recv( ~sid, $C, $S,
             <'13', certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'server', ~sid, hccc, hccs, fmc, fms )
   ]
  --[
  S_RecvReq( ~sid ),
  RecvReq( $S, ms, 'server',
           <'13', certificate_request_context, $certificate_extensions>
  ),
  Instance( ~sid, $S, $C, 'server' )
  ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   PendingReq( ~sid, 'server',
               <'13', certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

rule (modulo E) S_Send:
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   PendingReq( ~sid, 'server',
               <'13', ~certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'server', ~sid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ltkA ), DelegateLtk( $S, ltkA )
   ]
  --[
  S_Send( ~sid ), Owns( $S, ms, 'server', <$A, ltkA> ),
  Instance( ~sid, $S, $C, 'server' ),
  Fulfil( ~sid, $S, 'server',
          <'13', ~certificate_request_context, $certificate_extensions>,
          <$A, ltkA>
  )
  ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   TLS_Send( ~sid, $S, $C,
             <<'11', ~certificate_request_context, pk(ltkA)>, 
              <'15', 
               sign(<'ExportedAuthenticator', 
                     h(<hccs, 
                        <'13', ~certificate_request_context, $certificate_extensions>, 
                        pk(ltkA)>)
                    >,
                    ltkA)
              >, 
              '20', 
              hmac(<fms, hccs, 
                    <'13', ~certificate_request_context, $certificate_extensions>, 
                    <'11', ~certificate_request_context, pk(ltkA)>, '15', 
                    sign(<'ExportedAuthenticator', 
                          h(<hccs, 
                             <'13', ~certificate_request_context, $certificate_extensions>, 
                             pk(ltkA)>)
                         >,
                         ltkA)
                   >)
             >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S_Recv:
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   TLS_Recv( ~sid, $C, $S,
             <<'11', certificate_request_context, pk(ltkA)>, <'15', signature>, 
              '20', verify_data>
   ),
   PendingReq( ~sid, 'server',
               <'13', certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ms, 'server', ~sid, hccc, hccs, fmc, fms ),
   !Pk( $A, pk(ltkA) )
   ]
  --[
  S_Recv( ~sid ),
  Eq( verify(signature,
             <'ExportedAuthenticator', 
              h(<hccc, 
                 <'13', certificate_request_context, $certificate_extensions>, 
                 pk(ltkA)>)
             >,
             pk(ltkA)),
      true
  ),
  Eq( verify_data,
      hmac(<fmc, hccc, 
            <'13', certificate_request_context, $certificate_extensions>, 
            <'11', certificate_request_context, pk(ltkA)>, '15', signature>)
  ),
  Recv( $S, ms, 'server', <$A, pk(ltkA)> ),
  Fulfilled( ~sid, $S, 'server',
             <'13', certificate_request_context, $certificate_extensions>,
             <$A, pk(ltkA)>
  ),
  Instance( ~sid, $S, $C, 'server' )
  ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   !AcceptOwnership( ~sid, $C, $S, pk(ltkA) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) S_Recv:
     [
     F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
     TLS_Recv( ~sid, $C, $S,
               <<'11', certificate_request_context, pk(ltkA)>, <'15', signature>, 
                '20', verify_data>
     ),
     PendingReq( ~sid, 'server',
                 <'13', certificate_request_context, $certificate_extensions>
     ),
     !Exporters( ms, 'server', ~sid, hccc, hccs, fmc, fms ),
     !Pk( $A, pk(ltkA) )
     ]
    --[
    S_Recv( ~sid ), Eq( z, true ),
    Eq( verify_data,
        hmac(<fmc, hccc, 
              <'13', certificate_request_context, $certificate_extensions>, 
              <'11', certificate_request_context, pk(ltkA)>, '15', signature>)
    ),
    Recv( $S, ms, 'server', <$A, pk(ltkA)> ),
    Fulfilled( ~sid, $S, 'server',
               <'13', certificate_request_context, $certificate_extensions>,
               <$A, pk(ltkA)>
    ),
    Instance( ~sid, $S, $C, 'server' )
    ]->
     [
     F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
     !AcceptOwnership( ~sid, $C, $S, pk(ltkA) )
     ]
    variants (modulo AC)
    1. $certificate_extensions
             = $certificate_extensions.32
       certificate_request_context
             = certificate_request_context.35
       hccc  = hccc.38
       ltkA  = ltkA.40
       signature
             = sign(<'ExportedAuthenticator', 
                     h(<hccc.38, 
                        <'13', certificate_request_context.35, $certificate_extensions.32
                        >, 
                        pk(ltkA.40)>)
                    >,
                    ltkA.40)
       z     = true
    
    2. $certificate_extensions
             = $certificate_extensions.34
       certificate_request_context
             = certificate_request_context.37
       hccc  = hccc.40
       ltkA  = ltkA.42
       signature
             = signature.44
       z     = verify(signature.44,
                      <'ExportedAuthenticator', 
                       h(<hccc.40, 
                          <'13', certificate_request_context.37, $certificate_extensions.34
                          >, 
                          pk(ltkA.42)>)
                      >,
                      pk(ltkA.42))
    // loop breaker: [0]
  */

rule (modulo E) S_Send_Spontaneous:
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   !Exporters( ms, 'server', ~sid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ltkA ), DelegateLtk( $S, ltkA )
   ]
  --[
  S_Send( ~sid ), Owns( $S, ms, 'server', <$A, ltkA> ),
  Instance( ~sid, $S, $C, 'server' )
  ]->
   [
   F_State( ~sid, 'S1', $S, $C, 'server', auth_status ),
   TLS_Send( ~sid, $S, $C,
             <<'11', pk(ltkA)>, 
              <'15', sign(<'ExportedAuthenticator', h(<hccs, pk(ltkA)>)>, ltkA)
              >, 
              '20', 
              hmac(<fms, hccs, <'11', pk(ltkA)>, '15', 
                    sign(<'ExportedAuthenticator', h(<hccs, pk(ltkA)>)>, ltkA)>)
             >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

lemma one_start_per_tid [reuse]:
  all-traces
  "∀ tid actor actor2 peer peer2 role role2 #i #j.
    ((Start( tid, actor, peer, role ) @ #i) ∧
     (Start( tid, actor2, peer2, role2 ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor actor2 peer peer2 role role2 #i #j.
  (Start( tid, actor, peer, role ) @ #i) ∧
  (Start( tid, actor2, peer2, role2 ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma exists_Start:
  exists-trace
  "∃ tid actor peer role #j. Start( tid, actor, peer, role ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid actor peer role #j. (Start( tid, actor, peer, role ) @ #j)"
*/
by sorry

lemma tid_invariant [use_induction, reuse]:
  all-traces
  "∀ tid actor peer role #i.
    (Instance( tid, actor, peer, role ) @ #i) ⇒
    (∃ #j. (Start( tid, actor, peer, role ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor peer role #i.
  (Instance( tid, actor, peer, role ) @ #i)
 ∧
  ∀ #j. (Start( tid, actor, peer, role ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma Start_Self [reuse]:
  all-traces
  "∀ tid actor role #i.
    (Start( tid, actor, actor, role ) @ #i) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor role #i. (Start( tid, actor, actor, role ) @ #i)"
*/
by sorry

lemma Self_Reference [reuse]:
  all-traces
  "∀ tid actor role #i.
    (Instance( tid, actor, actor, role ) @ #i) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor role #i. (Instance( tid, actor, actor, role ) @ #i)"
*/
simplify
by contradiction /* from formulas */

restriction At_most_1_of_C0:
  "∀ #i1 #i2 a1v1 a2v1.
    ((C0( a1v1 ) @ #i1) ∧ (C0( a2v1 ) @ #i2)) ⇒ (#i1 = #i2)"
  // safety formula

restriction At_most_2_of_C_Req:
  "¬(∃ #i1 #i2 #i3 a1v1 a1v2 a2v1 a2v2 a3v1 a3v2.
      ((((C_Req( a1v1, a1v2 ) @ #i1) ∧ (C_Req( a2v1, a2v2 ) @ #i2)) ∧
        (C_Req( a3v1, a3v2 ) @ #i3)) ∧
       (#i1 < #i2)) ∧
      (#i2 < #i3))"
  // safety formula

restriction at_most_0_of_C_RecvReq:
  "∀ #i a1v1. (C_RecvReq( a1v1 ) @ #i) ⇒ (⊥)"
  // safety formula

restriction at_most_0_of_C_Send:
  "∀ #i a1v1. (C_Send( a1v1 ) @ #i) ⇒ (⊥)"
  // safety formula

restriction At_most_2_of_C_Recv:
  "¬(∃ #i1 #i2 #i3 a1v1 a2v1 a3v1.
      ((((C_Recv( a1v1 ) @ #i1) ∧ (C_Recv( a2v1 ) @ #i2)) ∧
        (C_Recv( a3v1 ) @ #i3)) ∧
       (#i1 < #i2)) ∧
      (#i2 < #i3))"
  // safety formula

restriction At_most_1_of_S0:
  "∀ #i1 #i2 a1v1 a2v1.
    ((S0( a1v1 ) @ #i1) ∧ (S0( a2v1 ) @ #i2)) ⇒ (#i1 = #i2)"
  // safety formula

restriction at_most_0_of_S_Req:
  "∀ #i a1v1 a1v2. (S_Req( a1v1, a1v2 ) @ #i) ⇒ (⊥)"
  // safety formula

restriction At_most_2_of_S_RecvReq:
  "¬(∃ #i1 #i2 #i3 a1v1 a2v1 a3v1.
      ((((S_RecvReq( a1v1 ) @ #i1) ∧ (S_RecvReq( a2v1 ) @ #i2)) ∧
        (S_RecvReq( a3v1 ) @ #i3)) ∧
       (#i1 < #i2)) ∧
      (#i2 < #i3))"
  // safety formula

restriction At_most_2_of_S_Send:
  "¬(∃ #i1 #i2 #i3 a1v1 a2v1 a3v1.
      ((((S_Send( a1v1 ) @ #i1) ∧ (S_Send( a2v1 ) @ #i2)) ∧
        (S_Send( a3v1 ) @ #i3)) ∧
       (#i1 < #i2)) ∧
      (#i2 < #i3))"
  // safety formula

restriction at_most_0_of_S_Recv:
  "∀ #i a1v1. (S_Recv( a1v1 ) @ #i) ⇒ (⊥)"
  // safety formula

lemma C_Send_RecvReq [reuse, use_induction]:
  all-traces
  "∀ tid #i.
    (C_Send( tid ) @ #i) ⇒ (∃ #j. (C_RecvReq( tid ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ tid #i.
  (C_Send( tid ) @ #i) ∧ ∀ #j. (C_RecvReq( tid ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  by contradiction /* from formulas */
qed

lemma StartFirst [reuse, use_induction]:
  all-traces
  "∀ tid actor peer role #i #j.
    ((Start( tid, actor, peer, role ) @ #i) ∧
     (Instance( tid, actor, peer, role ) @ #j)) ⇒
    (#i < #j)"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor peer role #i #j.
  (Start( tid, actor, peer, role ) @ #i) ∧
  (Instance( tid, actor, peer, role ) @ #j)
 ∧
  ¬(#i < #j)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  by contradiction /* from formulas */
qed

lemma exists_C1:
  exists-trace "∃ tid #j. C1( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (C1( tid ) @ #j)"
*/
simplify
solve( C1( tid ) @ #j )
  case C_1_bi
  solve( F_State( ~cid, 'C0', $C, $S, 'client', 'none' ) ▶₁ #j )
    case C_0
    solve( Create_TLS_Channel2( $C, ~cid, $S, sid, pk(ltkS) ) ▶₀ #j )
      case S_0
      solve( !Pk( $S, pk(~ltk) ) ▶₂ #j )
        case Register_pk
        solve( !Ltk( $C, ltkC ) ▶₃ #j )
          case Register_pk
          SOLVED // trace found
        qed
      qed
    qed
  qed
next
  case C_1_uni
  solve( F_State( ~cid, 'C0', $C, $S, 'client', 'none' ) ▶₁ #j )
    case C_0
    solve( Create_TLS_Channel2( $C, ~cid, $S, sid, pk(ltkS) ) ▶₀ #j )
      case S_0
      solve( !Pk( $S, pk(~ltk) ) ▶₂ #j )
        case Register_pk
        SOLVED // trace found
      qed
    qed
  qed
qed

lemma exists_S1:
  exists-trace "∃ tid #j. S1( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (S1( tid ) @ #j)"
*/
by sorry

lemma exists_CReq:
  exists-trace "∃ tid #j ctxt. C_Req( tid, ctxt ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j ctxt. (C_Req( tid, ctxt ) @ #j)"
*/
by sorry

lemma exists_C_RecvReq:
  exists-trace "∃ tid #j. C_RecvReq( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (C_RecvReq( tid ) @ #j)"
*/
by sorry

lemma exists_C_Send:
  exists-trace "∃ tid #j. C_Send( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (C_Send( tid ) @ #j)"
*/
by sorry

lemma exists_S_Send:
  exists-trace "∃ tid #j. S_Send( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (S_Send( tid ) @ #j)"
*/
by sorry

lemma exists_C_Recv:
  exists-trace "∃ tid #j. C_Recv( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (C_Recv( tid ) @ #j)"
*/
by sorry

lemma exists_S_Recv:
  exists-trace "∃ tid #j. S_Recv( tid ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j. (S_Recv( tid ) @ #j)"
*/
by sorry

lemma can_loop_S_Send:
  exists-trace
  "∃ tid #j #k.
    ((S_Send( tid ) @ #j) ∧ (S_Send( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (S_Send( tid ) @ #j) ∧ (S_Send( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_C_Send:
  exists-trace
  "∃ tid #j #k.
    ((C_Send( tid ) @ #j) ∧ (C_Send( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (C_Send( tid ) @ #j) ∧ (C_Send( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_S_Recv:
  exists-trace
  "∃ tid #j #k.
    ((S_Recv( tid ) @ #j) ∧ (S_Recv( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (S_Recv( tid ) @ #j) ∧ (S_Recv( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_C_Recv:
  exists-trace
  "∃ tid #j #k.
    ((C_Recv( tid ) @ #j) ∧ (C_Recv( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (C_Recv( tid ) @ #j) ∧ (C_Recv( tid ) @ #k) ∧ #j < #k"
*/
simplify
solve( C_Recv( tid ) @ #k )
  case C_Recv
  solve( Start( ~cid, $C, $S, 'client' ) @ #j.1 )
    case C_1_bi
    solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status ) ▶₀ #k )
      case C_1_bi
      by sorry
    next
      case C_Recv
      solve( (#j.1 = #vr)  ∥ (#vr < #j.1) )
        case case_1
        solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status
               ) ▶₀ #vr )
          case C_1_bi
          by contradiction /* non-injective facts (#j,#vr.2,#vr) */
        next
          case C_Recv
          by contradiction /* from formulas */
        next
          case C_Recv_Spontaneous
          by contradiction /* from formulas */
        next
          case C_Request
          solve( (¬(#vr.2 < #vr.12))  ∥ (¬(#vr.12 < #vr.2)) )
            case case_1
            solve( (#vr.2 = #vr.12)  ∥ (#vr.12 < #vr.2) )
              case case_1
              solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status
                     ) ▶₀ #vr.2 )
                case C_1_bi
                by sorry
              next
                case C_Recv
                by contradiction /* from formulas */
              next
                case C_Recv_Spontaneous
                by contradiction /* from formulas */
              next
                case C_Request
                solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status
                       ) ▶₀ #vr.12 )
                  case C_1_bi
                  solve( PendingReq( ~cid, 'client',
                                     <'13', certificate_request_context, $certificate_extensions>
                         ) ▶₂ #k )
                    case C_Request
                    solve( (#vr.2 = #vr.13)  ∥ (#vr.13 < #vr.2) )
                      case case_2
                      solve( (#vr.13 = #vr.12)  ∥ (#vr.12 < #vr.13) )
                        case case_1
                        solve( TLS_Recv( ~cid, $S, $C,
                                         <<'11', ~certificate_request_context, pk(ltkA)>, 
                                          <'15', 
                                           sign(<'ExportedAuthenticator', 
                                                 h(<hccs, 
                                                    <'13', ~certificate_request_context, 
                                                     $certificate_extensions>, 
                                                    pk(ltkA)>)
                                                >,
                                                ltkA)
                                          >, 
                                          '20', 
                                          hmac(<fms, hccs, 
                                                <'13', ~certificate_request_context, 
                                                 $certificate_extensions>, 
                                                <'11', ~certificate_request_context, pk(ltkA)>, 
                                                '15', 
                                                sign(<'ExportedAuthenticator', 
                                                      h(<hccs, 
                                                         <'13', ~certificate_request_context, 
                                                          $certificate_extensions>, 
                                                         pk(ltkA)>)
                                                     >,
                                                     ltkA)
                                               >)
                                         >
                               ) ▶₁ #k )
                          case Send_TLS_Channel_target
                          solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status.2
                                 ) ▶₀ #vr.14 )
                            case S_1_bi
                            by contradiction /* non-injective facts (#vr.6,#vr.15,#vr.14) */
                          next
                            case S_RecvReq
                            by sorry
                          next
                            case S_Send
                            solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status.2
                                   ) ▶₀ #vr.17 )
                              case S_1_bi
                              by contradiction /* non-injective facts (#vr.6,#vr.18,#vr.17) */
                            next
                              case S_RecvReq
                              solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status.2
                                     ) ▶₀ #vr.20 )
                                case S_1_bi
                                by sorry
                              next
                                case S_RecvReq
                                solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status.2
                                       ) ▶₀ #vr.21 )
                                  case S_1_bi
                                  solve( (#vr.20 = #vr.15)  ∥ (#vr.15 < #vr.20) )
                                    case case_1
                                    solve( (#vr.18 = #vr.20)  ∥ (#vr.20 < #vr.18) )
                                      case case_1
                                      solve( (#vr.5 = #vr.17)  ∥ (#vr.17 < #vr.5) )
                                        case case_1
                                        solve( TLS_Recv( ~sid, $C, $S,
                                                         <'13', ~certificate_request_context, 
                                                          $certificate_extensions>
                                               ) ▶₁ #vr.15 )
                                          case Send_TLS_Channel_owner
                                          solve( TLS_Recv( ~sid, $C, $S,
                                                           <'13', ~certificate_request_context.1, 
                                                            $certificate_extensions.1>
                                                 ) ▶₁ #vr.7 )
                                            case Send_TLS_Channel_owner
                                            solve( !Exporters( ms, 'client', ~cid, hccc,
                                                               Expand(Expand(Expand(~n,
                                                                                    <'32', 
                                                                                     'TLS13exportermastersecret', 
                                                                                     h(~n.1)>,
                                                                                    '32'),
                                                                             <'32', 
                                                                              'EXPORTER_serverauthenticatorhandshakecontext', 
                                                                              'empty'>,
                                                                             '32'),
                                                                      <'32', 'exporter', 
                                                                       h(<'empty', '32'>)>,
                                                                      '32'),
                                                               fmc,
                                                               Expand(Expand(Expand(~n,
                                                                                    <'32', 
                                                                                     'TLS13exportermastersecret', 
                                                                                     h(~n.1)>,
                                                                                    '32'),
                                                                             <'32', 
                                                                              'EXPORTER_serverauthenticatorfinishedkey', 
                                                                              'empty'>,
                                                                             '32'),
                                                                      <'32', 'exporter', 
                                                                       h(<'empty', '32'>)>,
                                                                      '32')
                                                   ) ▶₃ #k )
                                              case Create_TLS_channel_bi
                                              solve( !Pk( $A, pk(~ltk.2) ) ▶₄ #k )
                                                case Register_pk
                                                solve( Start( ~sid, $S, $C, 'server' ) @ #vr.6 )
                                                  case S_1_bi
                                                  solve( C_Recv( ~cid ) @ #vr )
                                                    case C_Recv
                                                    SOLVED // trace found
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      next
                                        case case_2
                                        by sorry
                                      qed
                                    next
                                      case case_2
                                      by sorry
                                    qed
                                  next
                                    case case_2
                                    by sorry
                                  qed
                                next
                                  case S_RecvReq
                                  by contradiction /* from formulas */
                                next
                                  case S_Send
                                  by contradiction /* from formulas */
                                next
                                  case S_Send_Spontaneous
                                  by contradiction /* from formulas */
                                qed
                              next
                                case S_Send
                                by contradiction /* from formulas */
                              next
                                case S_Send_Spontaneous
                                by contradiction /* from formulas */
                              qed
                            next
                              case S_Send
                              by contradiction /* from formulas */
                            next
                              case S_Send_Spontaneous
                              by contradiction /* from formulas */
                            qed
                          next
                            case S_Send_Spontaneous
                            by sorry
                          qed
                        qed
                      next
                        case case_2
                        by contradiction /* from formulas */
                      qed
                    qed
                  qed
                next
                  case C_Recv
                  by contradiction /* from formulas */
                next
                  case C_Recv_Spontaneous
                  by contradiction /* from formulas */
                next
                  case C_Request
                  by contradiction /* from formulas */
                qed
              qed
            next
              case case_2
              by contradiction /* non-injective facts (#vr.12,#vr.2,#vr) */
            qed
          next
            case case_2
            by sorry
          qed
        qed
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case C_Recv_Spontaneous
      by sorry
    next
      case C_Request
      by sorry
    qed
  next
    case C_1_uni
    by sorry
  qed
next
  case C_Recv_Spontaneous
  solve( Start( ~cid, $C, $S, 'client' ) @ #j.1 )
    case C_1_bi
    solve( !Ltk( $C, ltkC ) ▶₃ #j )
      case Register_pk
      solve( !Pk( $S, pk(ltkS) ) ▶₂ #j )
        case Register_pk
        solve( Create_TLS_Channel2( $C, ~cid, $S, sid, pk(~ltk) ) ▶₀ #j )
          case S_0
          solve( !Pk( $A, pk(ltkA) ) ▶₃ #k )
            case Register_pk
            solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status ) ▶₀ #k )
              case C_1_bi
              by sorry
            next
              case C_Recv
              by sorry
            next
              case C_Recv_Spontaneous
              solve( (#j.1 = #vr.5)  ∥ (#vr.5 < #j.1) )
                case case_1
                solve( F_State( ~cid, 'C1', $C, $S, 'client', auth_status
                       ) ▶₀ #j.1 )
                  case C_1_bi
                  solve( C_Recv( ~cid ) @ #j.1 )
                    case C_Recv_Spontaneous
                    solve( Start( ~sid, $S, $C, 'server' ) @ #vr.9 )
                      case S_1_bi
                      solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status
                             ) ▶₀ #vr.8 )
                        case S_1_bi
                        by sorry
                      next
                        case S_RecvReq
                        by sorry
                      next
                        case S_Send
                        by sorry
                      next
                        case S_Send_Spontaneous
                        solve( F_State( ~sid, 'S1', $S, $C, 'server', auth_status
                               ) ▶₀ #vr.10 )
                          case S_1_bi
                          solve( TLS_Recv( ~cid, $S, $C,
                                           <<'11', pk(~ltk.2)>, 
                                            <'15', 
                                             sign(<'ExportedAuthenticator', h(<hccs, pk(~ltk.2)>)>,
                                                  ~ltk.2)
                                            >, 
                                            '20', 
                                            hmac(<fms, hccs, <'11', pk(~ltk.2)>, '15', 
                                                  sign(<'ExportedAuthenticator', 
                                                        h(<hccs, pk(~ltk.2)>)>,
                                                       ~ltk.2)
                                                 >)
                                           >
                                 ) ▶₁ #k )
                            case Send_TLS_Channel_target
                            solve( (#vr.8 = #vr.13)  ∥ (#vr.13 < #vr.8) )
                              case case_2
                              solve( (#vr.13 = #vr.10)  ∥ (#vr.10 < #vr.13) )
                                case case_1
                                solve( !Exporters( ms, 'client', ~cid, hccc,
                                                   Expand(Expand(Expand(~n,
                                                                        <'32', 
                                                                         'TLS13exportermastersecret', 
                                                                         h(~n.1)>,
                                                                        '32'),
                                                                 <'32', 
                                                                  'EXPORTER_serverauthenticatorhandshakecontext', 
                                                                  'empty'>,
                                                                 '32'),
                                                          <'32', 'exporter', h(<'empty', '32'>)>,
                                                          '32'),
                                                   fmc,
                                                   Expand(Expand(Expand(~n,
                                                                        <'32', 
                                                                         'TLS13exportermastersecret', 
                                                                         h(~n.1)>,
                                                                        '32'),
                                                                 <'32', 
                                                                  'EXPORTER_serverauthenticatorfinishedkey', 
                                                                  'empty'>,
                                                                 '32'),
                                                          <'32', 'exporter', h(<'empty', '32'>)>,
                                                          '32')
                                       ) ▶₂ #k )
                                  case Create_TLS_channel_bi
                                  SOLVED // trace found
                                qed
                              next
                                case case_2
                                by contradiction /* from formulas */
                              qed
                            qed
                          qed
                        next
                          case S_RecvReq
                          by sorry
                        next
                          case S_Send
                          by contradiction /* from formulas */
                        next
                          case S_Send_Spontaneous
                          by contradiction /* from formulas */
                        qed
                      qed
                    qed
                  qed
                next
                  case C_Recv
                  by contradiction /* from formulas */
                next
                  case C_Recv_Spontaneous
                  by contradiction /* from formulas */
                next
                  case C_Request
                  by sorry
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case C_Request
              by sorry
            qed
          qed
        qed
      qed
    qed
  next
    case C_1_uni
    by sorry
  qed
qed

/* All well-formedness checks were successful. */

end