theory ExportedAuthenticators_lemmas begin

// Function signature and definition of the equational theory E

functions: Expand/3, Exporter/3, Extract/2, adec/2, aenc/2, fst/1,
           h/1, hmac/1, mac/1, mask/2, pair/2, pk/1, sign/2, snd/1, true/0,
           unmask/2, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    unmask(mask(x, y), x) = y,
    unmask(mask(x, y), y) = x,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

section{* TLS Exported Authenticators*}

restriction Eq_check_succeed:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Neq_check_succeed:
  "∀ x y #i. (Neq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

restriction pair_or_swapped:
  "∀ x y a b #i.
    (Check_pair_or_swapped( x, y, a, b ) @ #i) ⇒
    (((x = a) ∧ (y = b)) ∨ ((x = b) ∧ (y = a)))"
  // safety formula

rule (modulo E) Reveal_ltk:
   [ !Ltk( A, ltk ) ] --[ RevLtk( A ) ]-> [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_Adv_TLS_channel:
   [ Fr( ms ), Fr( TLS_transcript ), Fr( ~owner_cid ), Fr( cid ) ]
  --[ Adv_TLS( $I, ~owner_cid ) ]->
   [
   !TLS_Channel( ms, TLS_transcript, 'uni', $I, ~owner_cid, $S, cid ),
   !Exporters( ms, 'server', cid,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   ),
   ServerStart( cid ),
   Out( <~owner_cid, 
         Expand(Expand(Expand(ms,
                              <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                       <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                       '32'),
                <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
         Expand(Expand(Expand(ms,
                              <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                       <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                       '32'),
                <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
         Expand(Expand(Expand(ms,
                              <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                       <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
         Expand(Expand(Expand(ms,
                              <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                       <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                <'32', 'exporter', h(<'empty', '32'>)>, '32')
        >
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adv_Send_TLS:
   [
   In( <~owner_cid, m> ),
   !TLS_Channel( ms, TLS_transcript, auth_status, $I, ~owner_cid, $S,
                 cid
   )
   ]
  --[ A_Send( ~owner_cid ) ]->
   [ TLS_Send( ~owner_cid, $I, $S, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adv_Recv_TLS:
   [ TLS_Recv( ~owner_cid, from_host, to_host, msg ), In( ~owner_cid )
   ]
  --[ A_Recv( ~owner_cid ) ]->
   [ Out( <from_host, to_host, msg> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Register_pk:
   [ Fr( ~ltk ) ]
  -->
   [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ), DelegateLtk( $TP, ~ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   [ !Pk( A, pubkey ) ] --> [ Out( pubkey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_TLS_channel_bi:
   [
   Fr( ms ), Fr( TLS_transcript ), Fr( cid ),
   Create_TLS_Channel( owner_host, owner_cid, target_host )
   ]
  --[ SessionKey( ms, TLS_transcript ) ]->
   [
   !TLS_Channel( ms, TLS_transcript, 'bi', owner_host, owner_cid,
                 target_host, cid
   ),
   !Exporters( ms, 'server', cid,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   ),
   ServerStart( cid ),
   !Exporters( ms, 'client', owner_cid,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_TLS_channel_uni:
   [
   Fr( ms ), Fr( TLS_transcript ), Fr( cid ),
   Create_TLS_Channel( owner_host, owner_cid, target_host )
   ]
  --[ SessionKey( ms, TLS_transcript ) ]->
   [
   !TLS_Channel( ms, TLS_transcript, 'uni', 'place_holder', owner_cid,
                 target_host, cid
   ),
   !Exporters( ms, 'server', cid,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   ),
   ServerStart( cid ),
   !Exporters( ms, 'client', owner_cid,
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 'empty'>,
                             '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_clientauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32'),
               Expand(Expand(Expand(ms,
                                    <'32', 'TLS13exportermastersecret', h(TLS_transcript)>, '32'),
                             <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'>, '32'),
                      <'32', 'exporter', h(<'empty', '32'>)>, '32')
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_TLS_Channel_owner_bi:
   [
   TLS_Send( cid, from_host, to_host, msg ),
   !TLS_Channel( ms, TLS_transcript, 'bi', owner_host, owner_cid,
                 target_host, target_cid
   )
   ]
  --[
  Check_pair_or_swapped( from_host, to_host, owner_host, target_host
  ),
  Eq( cid, owner_cid )
  ]->
   [ TLS_Recv( target_cid, from_host, to_host, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_TLS_Channel_owner_uni:
   [
   TLS_Send( cid, from_host, to_host, msg ),
   !TLS_Channel( ms, TLS_transcript, 'uni', owner_host, owner_cid,
                 target_host, target_cid
   )
   ]
  --[ Eq( to_host, target_host ), Eq( cid, owner_cid ) ]->
   [ TLS_Recv( target_cid, owner_host, to_host, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send_TLS_Channel_target:
   [
   TLS_Send( cid, from_host, to_host, msg ),
   !TLS_Channel( ms, TLS_transcript, auth_status, owner_host,
                 owner_cid, target_host, target_cid
   )
   ]
  --[
  Check_pair_or_swapped( from_host, to_host, owner_host, target_host
  ),
  Eq( cid, target_cid )
  ]->
   [ TLS_Recv( owner_cid, from_host, to_host, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_0:
   [ Fr( ~tid ) ]
  --[ Start( ~tid, $C, $S, 'client' ), C0( ~tid ) ]->
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   Create_TLS_Channel( $C, ~tid, $S )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) C_Request:
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   Fr( ~certificate_request_context )
   ]
  --[
  C_Req( ~tid, ~certificate_request_context ),
  Instance( ~tid, $C, $S, 'client' )
  ]->
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   TLS_Send( ~tid, $C, $S,
             <'13', ~certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) C_Send:
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   Fr( ~certificate_request_context ),
   !Exporters( ~ms, 'client', ~tid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ~ltkA ), DelegateLtk( $C, ~ltkA )
   ]
  --[
  C_Send( ~tid ), Owns( $C, ~ms, 'client', <$A, ~ltkA> ),
  Instance( ~tid, $C, $S, 'client' )
  ]->
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   TLS_Send( ~tid, $C, $S,
             <<'11', ~certificate_request_context, pk(~ltkA)>, 
              <'15', sign(<'ExportedAuthenticator', h(<hccc, pk(~ltkA)>)>, ~ltkA)
              >, 
              '20', 
              hmac(<fmc, hccc, <'11', ~certificate_request_context, pk(~ltkA)>, 
                    '15', sign(<'ExportedAuthenticator', h(<hccc, pk(~ltkA)>)>, ~ltkA)
                   >)
             >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) C_Recv:
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   TLS_Recv( ~tid, $PH, $S,
             <<'11', certificate_request_context, pk(~ltkA)>, 
              <'15', signature>, '20', verify_data>
   ),
   !Exporters( ~ms, 'client', ~tid, hccc, hccs, fmc, fms ),
   !Pk( $A, pk(~ltkA) )
   ]
  --[
  C_Recv( ~tid ),
  Eq( verify(signature,
             <'ExportedAuthenticator', h(<hccs, pk(~ltkA)>)>, pk(~ltkA)),
      true
  ),
  Eq( verify_data,
      hmac(<fms, hccs, <'11', certificate_request_context, pk(~ltkA)>, 
            '15', signature>)
  ),
  Recv( $C, ~ms, 'client', <$A, pk(~ltkA)> ),
  Instance( ~tid, $C, $S, 'client' )
  ]->
   [
   State( ~tid, 'C0', $C, $S, 'client' ),
   !AcceptOwnership( ~tid, $C, $S, pk(~ltkA) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) C_Recv:
     [
     State( ~tid, 'C0', $C, $S, 'client' ),
     TLS_Recv( ~tid, $PH, $S,
               <<'11', certificate_request_context, pk(~ltkA)>, 
                <'15', signature>, '20', verify_data>
     ),
     !Exporters( ~ms, 'client', ~tid, hccc, hccs, fmc, fms ),
     !Pk( $A, pk(~ltkA) )
     ]
    --[
    C_Recv( ~tid ), Eq( z, true ),
    Eq( verify_data,
        hmac(<fms, hccs, <'11', certificate_request_context, pk(~ltkA)>, 
              '15', signature>)
    ),
    Recv( $C, ~ms, 'client', <$A, pk(~ltkA)> ),
    Instance( ~tid, $C, $S, 'client' )
    ]->
     [
     State( ~tid, 'C0', $C, $S, 'client' ),
     !AcceptOwnership( ~tid, $C, $S, pk(~ltkA) )
     ]
    variants (modulo AC)
    1. ~ltkA = ~ltkA.29
       hccs  = hccs.36
       signature
             = sign(<'ExportedAuthenticator', h(<hccs.36, pk(~ltkA.29)>)>,
                    ~ltkA.29)
       z     = true
    
    2. ~ltkA = ~ltkA.30
       hccs  = hccs.37
       signature
             = signature.38
       z     = verify(signature.38,
                      <'ExportedAuthenticator', h(<hccs.37, pk(~ltkA.30)>)>,
                      pk(~ltkA.30))
    // loop breaker: [0]
  */

rule (modulo E) S_0:
   [
   !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms ),
   ServerStart( ~tid )
   ]
  --[ Start( ~tid, $S, $C, 'server' ), S0( ~tid ) ]->
   [ State( ~tid, 'S0', $S, $C, 'server' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) S_Recv:
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   TLS_Recv( ~tid, $C, $S,
             <<'11', certificate_request_context, pk(~ltkA)>, 
              <'15', signature>, '20', verify_data>
   ),
   !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms ),
   !Pk( $A, pk(~ltkA) )
   ]
  --[
  S_Recv( ~tid ),
  Eq( verify(signature,
             <'ExportedAuthenticator', h(<hccc, pk(~ltkA)>)>, pk(~ltkA)),
      true
  ),
  Eq( verify_data,
      hmac(<fmc, hccc, <'11', certificate_request_context, pk(~ltkA)>, 
            '15', signature>)
  ),
  Recv( $S, ~ms, 'server', <$A, pk(~ltkA)> ),
  Instance( ~tid, $S, $C, 'server' )
  ]->
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   !AcceptOwnership( ~tid, $C, $S, pk(~ltkA) )
   ]

  // loop breaker: [0]
  /*
  rule (modulo AC) S_Recv:
     [
     State( ~tid, 'S0', $S, $C, 'server' ),
     TLS_Recv( ~tid, $C, $S,
               <<'11', certificate_request_context, pk(~ltkA)>, 
                <'15', signature>, '20', verify_data>
     ),
     !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms ),
     !Pk( $A, pk(~ltkA) )
     ]
    --[
    S_Recv( ~tid ), Eq( z, true ),
    Eq( verify_data,
        hmac(<fmc, hccc, <'11', certificate_request_context, pk(~ltkA)>, 
              '15', signature>)
    ),
    Recv( $S, ~ms, 'server', <$A, pk(~ltkA)> ),
    Instance( ~tid, $S, $C, 'server' )
    ]->
     [
     State( ~tid, 'S0', $S, $C, 'server' ),
     !AcceptOwnership( ~tid, $C, $S, pk(~ltkA) )
     ]
    variants (modulo AC)
    1. ~ltkA = ~ltkA.27
       hccc  = hccc.33
       signature
             = sign(<'ExportedAuthenticator', h(<hccc.33, pk(~ltkA.27)>)>,
                    ~ltkA.27)
       z     = true
    
    2. ~ltkA = ~ltkA.29
       hccc  = hccc.35
       signature
             = signature.37
       z     = verify(signature.37,
                      <'ExportedAuthenticator', h(<hccc.35, pk(~ltkA.29)>)>,
                      pk(~ltkA.29))
    // loop breaker: [0]
  */

rule (modulo E) S_Send_Spontaneous:
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   Fr( ~certificate_request_context ),
   !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ~ltkA ), DelegateLtk( $S, ~ltkA )
   ]
  --[
  S_Send( ~tid ), Owns( $S, ~ms, 'server', <$A, ~ltkA> ),
  Instance( ~tid, $S, $C, 'server' )
  ]->
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   TLS_Send( ~tid, $C, $S,
             <<'11', ~certificate_request_context, pk(~ltkA)>, 
              <'15', sign(<'ExportedAuthenticator', h(<hccs, pk(~ltkA)>)>, ~ltkA)
              >, 
              '20', 
              hmac(<fms, hccs, <'11', ~certificate_request_context, pk(~ltkA)>, 
                    '15', sign(<'ExportedAuthenticator', h(<hccs, pk(~ltkA)>)>, ~ltkA)
                   >)
             >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) S_RecvReq:
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   TLS_Recv( ~tid, $C, $S,
             <'13', ~certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms )
   ]
  --[
  S_RecvReq( ~tid ),
  RecvReq( $S, ~ms, 'server',
           <'13', ~certificate_request_context, $certificate_extensions>
  ),
  Instance( ~tid, $S, $C, 'server' )
  ]->
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   PendingReq( ~tid,
               <'13', ~certificate_request_context, $certificate_extensions>
   )
   ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

rule (modulo E) S_Send:
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   PendingReq( ~tid,
               <'13', ~certificate_request_context, $certificate_extensions>
   ),
   !Exporters( ~ms, 'server', ~tid, hccc, hccs, fmc, fms ),
   !Ltk( $A, ~ltkA ), DelegateLtk( $S, ~ltkA )
   ]
  --[
  S_Send( ~tid ), Owns( $S, ~ms, 'server', <$A, ~ltkA> ),
  Instance( ~tid, $S, $C, 'server' )
  ]->
   [
   State( ~tid, 'S0', $S, $C, 'server' ),
   TLS_Send( ~tid, $C, $S,
             <<'11', ~certificate_request_context, pk(~ltkA)>, 
              <'15', sign(<'ExportedAuthenticator', h(<hccs, pk(~ltkA)>)>, ~ltkA)
              >, 
              '20', 
              hmac(<fms, hccs, <'11', ~certificate_request_context, pk(~ltkA)>, 
                    '15', sign(<'ExportedAuthenticator', h(<hccs, pk(~ltkA)>)>, ~ltkA)
                   >)
             >
   )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

lemma uniq_Start:
  all-traces
  "∀ tid actor1 actor2 peer1 peer2 role1 role2 #i #j.
    ((Start( tid, actor1, peer1, role1 ) @ #i) ∧
     (Start( tid, actor2, peer2, role2 ) @ #j)) ⇒
    ((((#i = #j) ∧ (actor1 = actor2)) ∧ (peer1 = peer2)) ∧
     (role1 = role2))"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor1 actor2 peer1 peer2 role1 role2 #i #j.
  (Start( tid, actor1, peer1, role1 ) @ #i) ∧
  (Start( tid, actor2, peer2, role2 ) @ #j)
 ∧
  ((¬(#i = #j)) ∨
   (¬(actor1 = actor2)) ∨
   (¬(peer1 = peer2)) ∨
   (¬(role1 = role2)))"
*/
by sorry

lemma tid_invariant [use_induction, reuse]:
  all-traces
  "∀ tid actor peer role #i.
    (Instance( tid, actor, peer, role ) @ #i) ⇒
    (∃ #j. (Start( tid, actor, peer, role ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor peer role #i.
  (Instance( tid, actor, peer, role ) @ #i)
 ∧
  ∀ #j. (Start( tid, actor, peer, role ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma one_start_per_tid [reuse]:
  all-traces
  "∀ tid actor actor2 peer peer2 role role2 #i #j.
    ((Start( tid, actor, peer, role ) @ #i) ∧
     (Start( tid, actor2, peer2, role2 ) @ #j)) ⇒
    (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor actor2 peer peer2 role role2 #i #j.
  (Start( tid, actor, peer, role ) @ #i) ∧
  (Start( tid, actor2, peer2, role2 ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma exists_Start:
  exists-trace
  "∃ tid actor peer role #j. Start( tid, actor, peer, role ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ tid actor peer role #j. (Start( tid, actor, peer, role ) @ #j)"
*/
by sorry

lemma constant_peer:
  all-traces
  "∀ tid actor actor2 peer peer2 role role2 #i #j.
    ((Instance( tid, actor, peer, role ) @ #i) ∧
     (Start( tid, actor2, peer2, role2 ) @ #j)) ⇒
    (((actor = actor2) ∧ (peer = peer2)) ∧ (role = role2))"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor actor2 peer peer2 role role2 #i #j.
  (Instance( tid, actor, peer, role ) @ #i) ∧
  (Start( tid, actor2, peer2, role2 ) @ #j)
 ∧
  ((¬(actor = actor2)) ∨ (¬(peer = peer2)) ∨ (¬(role = role2)))"
*/
by sorry

lemma consistent_nonce:
  all-traces
  "∀ tid actor peer role actor2 peer2 role2 #i #j.
    ((Instance( tid, actor, peer, role ) @ #i) ∧
     (Instance( tid, actor2, peer2, role2 ) @ #j)) ⇒
    (((actor = actor2) ∧ (peer = peer2)) ∧ (role = role2))"
/*
guarded formula characterizing all counter-examples:
"∃ tid actor peer role actor2 peer2 role2 #i #j.
  (Instance( tid, actor, peer, role ) @ #i) ∧
  (Instance( tid, actor2, peer2, role2 ) @ #j)
 ∧
  ((¬(actor = actor2)) ∨ (¬(peer = peer2)) ∨ (¬(role = role2)))"
*/
by sorry

lemma can_loop_S_Send:
  exists-trace
  "∃ tid #j #k.
    ((S_Send( tid ) @ #j) ∧ (S_Send( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (S_Send( tid ) @ #j) ∧ (S_Send( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_C_Send:
  exists-trace
  "∃ tid #j #k.
    ((C_Send( tid ) @ #j) ∧ (C_Send( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (C_Send( tid ) @ #j) ∧ (C_Send( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_S_Recv:
  exists-trace
  "∃ tid #j #k.
    ((S_Recv( tid ) @ #j) ∧ (S_Recv( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (S_Recv( tid ) @ #j) ∧ (S_Recv( tid ) @ #k) ∧ #j < #k"
*/
by sorry

lemma can_loop_C_Recv:
  exists-trace
  "∃ tid #j #k.
    ((C_Recv( tid ) @ #j) ∧ (C_Recv( tid ) @ #k)) ∧ (#j < #k)"
/*
guarded formula characterizing all satisfying traces:
"∃ tid #j #k.
  (C_Recv( tid ) @ #j) ∧ (C_Recv( tid ) @ #k) ∧ #j < #k"
*/
simplify
solve( !Exporters( ~ms.1, 'client', ~tid, hccc.1, hccs.1, fmc.1,
                   fms.1
       ) ▶₂ #k )
  case Create_TLS_channel_bi
  solve( !Exporters( ~ms, 'client', ~tid, hccc, hccs, fmc, fms
         ) ▶₂ #j )
    case Create_TLS_channel_bi
    solve( TLS_Recv( ~tid, $PH.1, $S.1,
                     <<'11', certificate_request_context.1, pk(~ltkA.1)>, 
                      <'15', 
                       sign(<'ExportedAuthenticator', 
                             h(<
                                Expand(Expand(Expand(~ms,
                                                     <'32', 'TLS13exportermastersecret', h(~n)>,
                                                     '32'),
                                              <'32', 
                                               'EXPORTER_serverauthenticatorhandshakecontext', 
                                               'empty'>,
                                              '32'),
                                       <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
                                pk(~ltkA.1)>)
                            >,
                            ~ltkA.1)
                      >, 
                      '20', 
                      hmac(<
                            Expand(Expand(Expand(~ms,
                                                 <'32', 'TLS13exportermastersecret', h(~n)>, '32'),
                                          <'32', 'EXPORTER_serverauthenticatorfinishedkey', 'empty'
                                          >,
                                          '32'),
                                   <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
                            Expand(Expand(Expand(~ms,
                                                 <'32', 'TLS13exportermastersecret', h(~n)>, '32'),
                                          <'32', 'EXPORTER_serverauthenticatorhandshakecontext', 
                                           'empty'>,
                                          '32'),
                                   <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
                            <'11', certificate_request_context.1, pk(~ltkA.1)>, '15', 
                            sign(<'ExportedAuthenticator', 
                                  h(<
                                     Expand(Expand(Expand(~ms,
                                                          <'32', 'TLS13exportermastersecret', h(~n)
                                                          >,
                                                          '32'),
                                                   <'32', 
                                                    'EXPORTER_serverauthenticatorhandshakecontext', 
                                                    'empty'>,
                                                   '32'),
                                            <'32', 'exporter', h(<'empty', '32'>)>, '32'), 
                                     pk(~ltkA.1)>)
                                 >,
                                 ~ltkA.1)
                           >)
                     >
           ) ▶₁ #k )
      case Send_TLS_Channel_target_case_1
      by sorry
    next
      case Send_TLS_Channel_target_case_2
      solve( State( ~n.1, 'S0', $S.1, $PH.1, 'server' ) ▶₀ #vr.2 )
        case S_0
        by sorry
      next
        case S_RecvReq
        by sorry
      next
        case S_Recv_case_1
        by sorry
      next
        case S_Recv_case_2
        by sorry
      next
        case S_Send
        solve( State( ~n.1, 'S0', $S.1, $PH.1, 'server' ) ▶₀ #vr.5 )
          case S_0
          by sorry
        next
          case S_RecvReq
          solve( State( ~n.1, 'S0', $S.1, $PH.1, 'server' ) ▶₀ #vr.8 )
            case S_0
            by sorry
          next
            case S_RecvReq
            solve( State( ~n.1, 'S0', $S.1, $PH.1, 'server' ) ▶₀ #vr.9 )
              case S_0
              solve( State( ~n.1, 'S0', $S.3, $C.3, 'server' ) ▶₀ #vr.3 )
                case S_0
                by sorry /* removed */
              next
                case S_RecvReq
                solve( State( ~n.1, 'S0', $S.3, $C.3, 'server' ) ▶₀ #vr.10 )
                  case S_0
                  solve( State( ~n.1, 'S0', $S.3, $C.3, 'server' ) ▶₀ #vr.6 )
                    case S_0
                    solve( State( ~tid, 'C0', $C.1, $S.1, 'client' ) ▶₀ #k )
                      case C_0
                      by sorry
                    next
                      case C_Recv_case_1
                      by sorry
                    next
                      case C_Recv_case_2
                      solve( State( ~tid, 'C0', $C.1, $S.1, 'client' ) ▶₀ #vr.8 )
                        case C_0
                        by sorry
                      next
                        case C_Recv_case_1
                        by sorry
                      next
                        case C_Recv_case_2
                        by sorry
                      next
                        case C_Request
                        solve( State( ~tid, 'C0', $C.1, $S.1, 'client' ) ▶₀ #vr.13 )
                          case C_0
                          by sorry
                        next
                          case C_Recv_case_1
                          by sorry
                        next
                          case C_Recv_case_2
                          by sorry
                        next
                          case C_Request
                          solve( State( ~tid, 'C0', $C.1, $S.1, 'client' ) ▶₀ #vr.14 )
                            case C_0
                            solve( State( ~n.1, 'S0', $S.1, $PH.2, 'server' ) ▶₀ #vr.11 )
                              case S_RecvReq
                              solve( State( ~n.1, 'S0', $S.1, $PH.2, 'server' ) ▶₀ #vr.15 )
                                case S_RecvReq
                                solve( State( ~n.1, 'S0', $S.1, $PH.2, 'server' ) ▶₀ #vr.16 )
                                  case S_0
                                  solve( TLS_Recv( ~n.1, $PH.1, $S.1,
                                                   <'13', ~certificate_request_context.1, 
                                                    $certificate_extensions>
                                         ) ▶₁ #vr.3 )
                                    case Send_TLS_Channel_owner_bi_case_1
                                    by sorry
                                  next
                                    case Send_TLS_Channel_owner_bi_case_2
                                    solve( State( ~tid, 'C0', $PH.1, $S.1, 'client' ) ▶₀ #vr.13 )
                                      case C_0
                                      by sorry
                                    next
                                      case C_Recv_case_1
                                      by sorry
                                    next
                                      case C_Recv_case_2
                                      by sorry
                                    next
                                      case C_Request
                                      solve( State( ~tid, 'C0', $PH.1, $S.1, 'client' ) ▶₀ #vr.14 )
                                        case C_0
                                        solve( TLS_Recv( ~n.1, $C.1, $S.1,
                                                         <'13', ~certificate_request_context.2, 
                                                          $certificate_extensions.1>
                                               ) ▶₁ #vr.6 )
                                          case Send_TLS_Channel_owner_bi_case_1
                                          by sorry
                                        next
                                          case Send_TLS_Channel_owner_bi_case_2
                                          solve( State( ~tid, 'C0', $C.1, $S.1, 'client'
                                                 ) ▶₀ #vr.14 )
                                            case C_0
                                            solve( !Pk( $A, pk(~ltkA) ) ▶₃ #j )
                                              case Register_pk
                                              solve( !Pk( $A.1, pk(~ltkA.1) ) ▶₃ #k )
                                                case Register_pk
                                                solve( Start( ~tid, $C, $S, 'client' ) @ #j.1 )
                                                  case C_0
                                                  solve( Start( ~n.1, $S, $C, 'server' ) @ #j.2 )
                                                    case S_0
                                                    solve( State( ~tid, 'C0', $C, $S, 'client'
                                                           ) ▶₀ #j )
                                                      case C_Recv_case_1
                                                      by sorry
                                                    next
                                                      case C_Recv_case_2
                                                      by sorry
                                                    next
                                                      case C_Request
                                                      solve( State( ~tid, 'C0', $C, $S, 'client'
                                                             ) ▶₀ #vr.15 )
                                                        case C_Recv_case_1
                                                        by sorry
                                                      next
                                                        case C_Recv_case_2
                                                        by sorry
                                                      next
                                                        case C_Request
                                                        solve( State( ~tid, 'C0', $C, $S, 'client'
                                                               ) ▶₀ #vr.16 )
                                                          case C_0
                                                          SOLVED // trace found
                                                        next
                                                          case C_Recv_case_1
                                                          by sorry
                                                        next
                                                          case C_Recv_case_2
                                                          by sorry
                                                        next
                                                          case C_Request
                                                          by sorry
                                                        next
                                                          case C_Send
                                                          by sorry
                                                        qed
                                                      next
                                                        case C_Send
                                                        by sorry
                                                      qed
                                                    next
                                                      case C_Send
                                                      by sorry
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          next
                                            case C_Recv_case_1
                                            by sorry
                                          next
                                            case C_Recv_case_2
                                            by sorry
                                          next
                                            case C_Request
                                            by sorry
                                          next
                                            case C_Send
                                            by sorry
                                          qed
                                        qed
                                      next
                                        case C_Recv_case_1
                                        by sorry
                                      next
                                        case C_Recv_case_2
                                        by sorry
                                      next
                                        case C_Request
                                        by sorry
                                      next
                                        case C_Send
                                        by sorry
                                      qed
                                    next
                                      case C_Send
                                      by sorry
                                    qed
                                  qed
                                next
                                  case S_RecvReq
                                  by sorry
                                next
                                  case S_Recv_case_1
                                  by sorry
                                next
                                  case S_Recv_case_2
                                  by sorry
                                next
                                  case S_Send
                                  by sorry
                                next
                                  case S_Send_Spontaneous
                                  by sorry
                                qed
                              next
                                case S_Recv_case_1
                                by sorry
                              next
                                case S_Recv_case_2
                                by sorry
                              next
                                case S_Send
                                by sorry
                              next
                                case S_Send_Spontaneous
                                by sorry
                              qed
                            next
                              case S_Recv_case_1
                              by sorry
                            next
                              case S_Recv_case_2
                              by sorry
                            next
                              case S_Send
                              by sorry
                            next
                              case S_Send_Spontaneous
                              by sorry
                            qed
                          next
                            case C_Recv_case_1
                            by sorry
                          next
                            case C_Recv_case_2
                            by sorry
                          next
                            case C_Request
                            by sorry
                          next
                            case C_Send
                            by sorry
                          qed
                        next
                          case C_Send
                          by sorry
                        qed
                      next
                        case C_Send
                        by sorry
                      qed
                    next
                      case C_Request
                      by sorry
                    next
                      case C_Send
                      by sorry
                    qed
                  next
                    case S_RecvReq
                    by sorry
                  next
                    case S_Recv_case_1
                    by sorry
                  next
                    case S_Recv_case_2
                    by sorry
                  next
                    case S_Send
                    by sorry
                  next
                    case S_Send_Spontaneous
                    by sorry
                  qed
                next
                  case S_RecvReq
                  by sorry
                next
                  case S_Recv_case_1
                  by sorry
                next
                  case S_Recv_case_2
                  by sorry
                next
                  case S_Send
                  by sorry
                next
                  case S_Send_Spontaneous
                  by sorry
                qed
              next
                case S_Recv_case_1
                by sorry
              next
                case S_Recv_case_2
                by sorry
              next
                case S_Send
                by sorry
              next
                case S_Send_Spontaneous
                by sorry
              qed
            next
              case S_RecvReq
              by sorry
            next
              case S_Recv_case_1
              by sorry
            next
              case S_Recv_case_2
              by sorry
            next
              case S_Send
              by sorry
            next
              case S_Send_Spontaneous
              by sorry
            qed
          next
            case S_Recv_case_1
            by sorry
          next
            case S_Recv_case_2
            by sorry
          next
            case S_Send
            by sorry
          next
            case S_Send_Spontaneous
            by sorry
          qed
        next
          case S_Recv_case_1
          by sorry
        next
          case S_Recv_case_2
          by sorry
        next
          case S_Send
          by sorry
        next
          case S_Send_Spontaneous
          by sorry
        qed
      next
        case S_Send_Spontaneous
        by sorry
      qed
    qed
  qed
next
  case Create_TLS_channel_uni
  by sorry
qed

lemma reachable_session_keys:
  exists-trace
  "∃ ms transcript #i. SessionKey( ms, transcript ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ ms transcript #i. (SessionKey( ms, transcript ) @ #i)"
*/
by sorry

lemma secret_session_keys:
  all-traces
  "∀ ms transcript #i.
    (SessionKey( ms, transcript ) @ #i) ⇒
    ((¬(∃ #j. K( ms ) @ #j)) ∧ (¬(∃ #k. K( transcript ) @ #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ ms transcript #i.
  (SessionKey( ms, transcript ) @ #i)
 ∧
  ((∃ #j. (K( ms ) @ #j)) ∨ (∃ #k. (K( transcript ) @ #k)))"
*/
by sorry

lemma cert_ownership:
  all-traces
  "∀ actor ms ltkD del role #k.
    (Recv( actor, ms, role, <del, pk(ltkD)> ) @ #k) ⇒
    ((∃ peer role2 #i.
       ((Owns( peer, ms, role2, <del, ltkD> ) @ #i) ∧ (#i < #k)) ∧
       (¬(role = role2))) ∨
     (∃ #j. (RevLtk( del ) @ #j) ∧ (#j < #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ actor ms ltkD del role #k.
  (Recv( actor, ms, role, <del, pk(ltkD)> ) @ #k)
 ∧
  (∀ peer role2 #i.
    (Owns( peer, ms, role2, <del, ltkD> ) @ #i)
   ⇒
    ((¬(#i < #k)) ∨ (role = role2))) ∧
  (∀ #j. (RevLtk( del ) @ #j) ⇒ ¬(#j < #k))"
*/
by sorry

lemma cert_linking:
  all-traces
  "∀ actor ms role ltkD del ltkD2 del2 #j #k.
    ((Recv( actor, ms, role, <del, pk(ltkD)> ) @ #j) ∧
     (Recv( actor, ms, role, <del2, pk(ltkD2)> ) @ #k)) ⇒
    (((∃ peer role2 #h #i.
        ((((Owns( peer, ms, role2, <del, ltkD> ) @ #h) ∧ (#h < #j)) ∧
          (Owns( peer, ms, role2, <del2, ltkD2> ) @ #i)) ∧
         (#i < #k)) ∧
        (¬(role = role2))) ∨
      (∃ #l. (RevLtk( del ) @ #l) ∧ (#l < #k))) ∨
     (∃ #l. (RevLtk( del2 ) @ #l) ∧ (#l < #k)))"
/*
guarded formula characterizing all counter-examples:
"∃ actor ms role ltkD del ltkD2 del2 #j #k.
  (Recv( actor, ms, role, <del, pk(ltkD)> ) @ #j) ∧
  (Recv( actor, ms, role, <del2, pk(ltkD2)> ) @ #k)
 ∧
  (∀ peer role2 #h #i.
    (Owns( peer, ms, role2, <del, ltkD> ) @ #h) ∧
    (Owns( peer, ms, role2, <del2, ltkD2> ) @ #i)
   ⇒
    ((¬(#h < #j)) ∨ (¬(#i < #k)) ∨ (role = role2))) ∧
  (∀ #l. (RevLtk( del ) @ #l) ⇒ ¬(#l < #k)) ∧
  (∀ #l. (RevLtk( del2 ) @ #l) ⇒ ¬(#l < #k))"
*/
by sorry

/*
WARNING: the following wellformedness checks failed!

restriction actions:
  restriction `Neq_check_succeed' references action 
    (ProtoFact Linear "Neq" 2,2,Linear)
  but no rule has such an action.
*/

end